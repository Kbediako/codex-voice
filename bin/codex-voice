#!/data/data/com.termux/files/usr/bin/sh

VOICE_DIR="$HOME/.codex/device"
SESSION_FILE="$VOICE_DIR/voice_session_id"
OUT_FILE="$VOICE_DIR/voice_last_message.txt"
MAX_TTS_CHARS=800
WAKE_PHRASE="codex"
NOTIF_ID=9101
NOTIF_TITLE="Codex Voice"
TTS_STREAM="MUSIC"
SAY_LISTENING="${CODEX_VOICE_SAY_LISTENING:-1}"
AUDIO_GAIN="${CODEX_VOICE_GAIN:-4.0}"
WHISPER_THREADS="${CODEX_VOICE_THREADS:-6}"
WHISPER_PROCS="${CODEX_VOICE_PROCS:-1}"
WHISPER_BS_WAKE="${CODEX_VOICE_BS_WAKE:-1}"
WHISPER_BO_WAKE="${CODEX_VOICE_BO_WAKE:-1}"
WHISPER_BS_CMD="${CODEX_VOICE_BS_CMD:-1}"
WHISPER_BO_CMD="${CODEX_VOICE_BO_CMD:-1}"
LOG_FILE="$VOICE_DIR/voice_debug.log"
WAKE_WINDOW_SECS=6
wake_buffer=""
wake_ts=0
HEARTBEAT_SECS=30
last_heartbeat=0
WHISPER_BIN="$HOME/bin/whisper-cpp"
WHISPER_MODEL_DIR="$VOICE_DIR/models"
WHISPER_MODEL_WAKE=""
WHISPER_MODEL_CMD=""
WHISPER_MODEL_CMD_OVERRIDE="${CODEX_VOICE_MODEL_CMD:-}"
WHISPER_MODEL_WAKE_OVERRIDE="${CODEX_VOICE_MODEL_WAKE:-}"
WAKE_ENGINE="${CODEX_VOICE_WAKE_ENGINE:-whisper}"
CMD_ENGINE="${CODEX_VOICE_CMD_ENGINE:-whisper}"
STT_TIMEOUT="${CODEX_VOICE_STT_TIMEOUT:-3}"
DEBUG_TOAST="${CODEX_VOICE_DEBUG_TOAST:-0}"
AUDIO_DIR="$VOICE_DIR/audio"
AUDIO_OPUS="$AUDIO_DIR/input.opus"
AUDIO_WAV="$AUDIO_DIR/input.wav"
TRANSCRIPT_BASE="$AUDIO_DIR/transcript"
RECORD_SECS=4
MIN_OPUS_BYTES=2000
RECORD_SECS_WAKE=1
RECORD_SECS_CMD=2
MIN_OPUS_BYTES_WAKE=120
MIN_OPUS_BYTES_CMD=700
MAX_COMMAND_RETRIES=1
LOCK_DIR="$VOICE_DIR/voice.lock"
LOCK_PID_FILE="$LOCK_DIR/pid"
has_lock=0

mkdir -p "$VOICE_DIR" "$AUDIO_DIR"

log() {
  printf '%s %s\n' "$(date '+%Y-%m-%d %H:%M:%S')" "$*" >> "$LOG_FILE"
}

get_mem_total_kb() {
  awk '/MemTotal/ {print $2}' /proc/meminfo 2>/dev/null
}

select_whisper_model() {
  mem_kb=$(get_mem_total_kb)
  candidates=""

  if [ -n "$mem_kb" ] && [ "$mem_kb" -ge 4500000 ]; then
    candidates="ggml-tiny.en.bin ggml-base.en.bin ggml-small.en.bin ggml-medium.en.bin"
  else
    candidates="ggml-tiny.en.bin ggml-base.en.bin"
  fi

  for model in $candidates; do
    if [ -f "$WHISPER_MODEL_DIR/$model" ]; then
      printf '%s' "$WHISPER_MODEL_DIR/$model"
      return
    fi
  done

  printf '%s' ""
}

resolve_model_override() {
  ov="$1"
  if [ -z "$ov" ]; then
    printf '%s' ""
    return
  fi
  if [ -f "$ov" ]; then
    printf '%s' "$ov"
    return
  fi
  if [ -f "$WHISPER_MODEL_DIR/$ov" ]; then
    printf '%s' "$WHISPER_MODEL_DIR/$ov"
    return
  fi
  printf '%s' ""
}

select_whisper_model_wake() {
  candidates="ggml-tiny.en.bin ggml-base.en.bin ggml-small.en.bin ggml-medium.en.bin ggml-large-v3.bin ggml-large.bin"
  for model in $candidates; do
    if [ -f "$WHISPER_MODEL_DIR/$model" ]; then
      printf '%s' "$WHISPER_MODEL_DIR/$model"
      return
    fi
  done
  printf '%s' ""
}

notify() {
  termux-notification -i "$NOTIF_ID" --ongoing --alert-once \
    -t "$NOTIF_TITLE" -c "$1" >/dev/null 2>&1 || true
}

cleanup() {
  termux-wake-unlock >/dev/null 2>&1 || true
  if [ "$has_lock" -eq 1 ]; then
    notify "Stopped"
    termux-notification-remove -i "$NOTIF_ID" >/dev/null 2>&1 || true
    rm -rf "$LOCK_DIR" >/dev/null 2>&1 || true
    log "Stopped"
  fi
}

trap cleanup INT TERM EXIT

acquire_lock() {
  if mkdir "$LOCK_DIR" 2>/dev/null; then
    echo "$$" > "$LOCK_PID_FILE"
    has_lock=1
    return 0
  fi

  # Wait briefly for the other instance to write its pid.
  i=0
  while [ $i -lt 10 ]; do
    if [ -f "$LOCK_PID_FILE" ]; then
      break
    fi
    sleep 0.1
    i=$((i+1))
  done

  lock_pid=""
  if [ -f "$LOCK_PID_FILE" ]; then
    lock_pid=$(cat "$LOCK_PID_FILE" 2>/dev/null)
  fi

  if [ -n "$lock_pid" ] && kill -0 "$lock_pid" 2>/dev/null; then
    log "Another instance already running (pid $lock_pid)"
    exit 0
  fi

  # If another codex-voice process exists, do not steal the lock.
  other_pid=$(pgrep -f "/codex-voice([[:space:]]|$)" | awk -v self="$$" '$1 != self {print $1; exit}')
  if [ -n "$other_pid" ]; then
    log "Another instance already running (pid $other_pid)"
    exit 0
  fi

  rm -rf "$LOCK_DIR" >/dev/null 2>&1 || true
  if mkdir "$LOCK_DIR" 2>/dev/null; then
    echo "$$" > "$LOCK_PID_FILE"
    has_lock=1
  else
    log "Failed to acquire lock"
    exit 0
  fi
}

latest_session_file() {
  ls -t "$HOME/.codex/sessions"/*/*/*/rollout-*.jsonl 2>/dev/null | head -n 1
}

extract_session_id() {
  echo "$1" | sed -E 's/.*-([0-9a-f-]{36})\.jsonl$/\1/'
}

init_session() {
  if [ -f "$SESSION_FILE" ]; then
    session_id=$(cat "$SESSION_FILE" 2>/dev/null)
    if [ -n "$session_id" ]; then
      echo "$session_id"
      return
    fi
  fi

  # Create a dedicated voice session if we don't have one yet.
  codex exec --skip-git-repo-check --color never \
    --output-last-message "$OUT_FILE" \
    "You are my hands-free voice assistant. Keep replies concise unless I ask for detail." \
    >/dev/null 2>&1 || true

  session_file=$(latest_session_file)
  session_id=$(extract_session_id "$session_file")
  if [ -n "$session_id" ]; then
    echo "$session_id" > "$SESSION_FILE"
    echo "$session_id"
  else
    echo ""
  fi
}

wait_for_recording_stop() {
  i=0
  while [ $i -lt 10 ]; do
    rec=$(termux-microphone-record -i 2>/dev/null | sed -n 's/.*"isRecording"[[:space:]]*:[[:space:]]*\\(true\\|false\\).*/\\1/p')
    if [ "$rec" = "false" ] || [ -z "$rec" ]; then
      return 0
    fi
    i=$((i+1))
    sleep 0.1
  done
  return 0
}

listen_once() {
  model="$1"
  record_secs="$2"
  min_bytes="$3"
  beam_size="$4"
  best_of="$5"
  engine="$6"
  if [ -z "$record_secs" ]; then
    record_secs="$RECORD_SECS"
  fi
  if [ -z "$min_bytes" ]; then
    min_bytes="$MIN_OPUS_BYTES"
  fi
  if [ "$engine" = "stt" ]; then
    if command -v timeout >/dev/null 2>&1; then
      out=$(timeout "$STT_TIMEOUT" termux-speech-to-text 2>>"$LOG_FILE")
      status=$?
      if [ "$status" -eq 124 ]; then
        log "speech-to-text timeout"
        echo ""
        return
      fi
    else
      out=$(termux-speech-to-text 2>>"$LOG_FILE")
      status=$?
    fi
    if [ "$status" -ne 0 ]; then
      log "speech-to-text exit $status"
    fi
    printf '%s' "$out" | awk 'NF{last=$0} END{print last}'
    return
  fi
  if [ -x "$WHISPER_BIN" ] && [ -n "$model" ] && [ -f "$model" ]; then
    termux-microphone-record -q >/dev/null 2>&1 || true
    rm -f "$AUDIO_OPUS" "$AUDIO_WAV" "${TRANSCRIPT_BASE}.txt"
    termux-microphone-record -f "$AUDIO_OPUS" -l "$record_secs" -e opus >/dev/null 2>&1 || true
    sleep "$record_secs"
    termux-microphone-record -q >/dev/null 2>&1 || true
    wait_for_recording_stop
    sleep 0.2
    if [ ! -s "$AUDIO_OPUS" ]; then
      log "no audio captured"
      echo ""
      return
    fi
    opus_bytes=$(wc -c < "$AUDIO_OPUS" | tr -d ' ')
    if [ "$opus_bytes" -lt "$min_bytes" ]; then
      log "audio too small (${opus_bytes} bytes)"
      echo ""
      return
    fi
    ffmpeg -loglevel error -y -i "$AUDIO_OPUS" -ar 16000 -ac 1 -af "volume=$AUDIO_GAIN" -f wav "$AUDIO_WAV" >/dev/null 2>>"$LOG_FILE"
    if [ ! -s "$AUDIO_WAV" ]; then
      log "ffmpeg failed"
      echo ""
      return
    fi
    "$WHISPER_BIN" -m "$model" -f "$AUDIO_WAV" -otxt -of "$TRANSCRIPT_BASE" -nt -np -l en \
      -t "$WHISPER_THREADS" -p "$WHISPER_PROCS" -bs "$beam_size" -bo "$best_of" \
      >/dev/null 2>>"$LOG_FILE"
    status=$?
    if [ "$status" -ne 0 ]; then
      log "whisper exit $status"
    fi
    if [ -s "${TRANSCRIPT_BASE}.txt" ]; then
      cat "${TRANSCRIPT_BASE}.txt"
    else
      echo ""
    fi
  else
    # termux-speech-to-text streams partial matches; take the last non-empty line.
    out=$(termux-speech-to-text 2>>"$LOG_FILE")
    status=$?
    if [ "$status" -ne 0 ]; then
      log "speech-to-text exit $status"
    fi
    printf '%s' "$out" | awk 'NF{last=$0} END{print last}'
  fi
}

normalize_text() {
  printf '%s' "$1" \
    | tr '[:upper:]' '[:lower:]' \
    | sed -E 's/[^a-z0-9 ]+/ /g; s/[[:space:]]+/ /g; s/^ //; s/ $//'
}

is_garbage_transcript() {
  case "$1" in
    ""|"blank audio"|"dramatic music"|"music"|"music playing"|"background music"|"footsteps"|"water splashing"|"silence"|"background noise"|"noise"|"listening"|"ready")
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

contains_wake() {
  case "$1" in
    *cod*|*kode*|*kodi*|*codi*|*cortex*)
      return 0
      ;;
  esac
  return 1
}

strip_wake() {
  printf '%s' "$1" \
    | sed -E 's/.*(yo|hey|hi|ok|okay) (codex|codec|code x|codexx|codexs|codexes|codix|kodex|kode|kodi|kody|cortex) ?//; s/.*(codex|codec|code x|codexx|codexs|codexes|codix|kodex|kode|kodi|kody|cortex|cod|code|codes|codecs|cods) ?//'
}

speak() {
  # Use notification stream by default; adjust with termux-tts-speak flags if desired.
  termux-tts-speak -s "$TTS_STREAM" "$1"
}

say_response() {
  if [ ! -s "$OUT_FILE" ]; then
    speak "I didn't get a response."
    return
  fi

  resp=$(cat "$OUT_FILE")
  resp_len=$(printf '%s' "$resp" | wc -c | tr -d ' ')
  if [ "$resp_len" -gt "$MAX_TTS_CHARS" ]; then
    short_resp=$(printf '%s' "$resp" | head -c "$MAX_TTS_CHARS")
    speak "$short_resp"
    speak "Response truncated. Check the terminal for full text."
    printf '%s\n' "$resp"
  else
    speak "$resp"
    printf '%s\n' "$resp"
  fi
}

acquire_lock
WHISPER_MODEL_CMD=$(select_whisper_model)
WHISPER_MODEL_WAKE=$(select_whisper_model_wake)
cmd_override=$(resolve_model_override "$WHISPER_MODEL_CMD_OVERRIDE")
if [ -n "$cmd_override" ]; then
  WHISPER_MODEL_CMD="$cmd_override"
fi
wake_override=$(resolve_model_override "$WHISPER_MODEL_WAKE_OVERRIDE")
if [ -n "$wake_override" ]; then
  WHISPER_MODEL_WAKE="$wake_override"
fi
if [ -z "$WHISPER_MODEL_WAKE" ]; then
  WHISPER_MODEL_WAKE="$WHISPER_MODEL_CMD"
fi
session_id=$(init_session)

termux-wake-lock >/dev/null 2>&1 || true
if [ -x "$WHISPER_BIN" ] && [ -n "$WHISPER_MODEL_CMD" ] && [ -f "$WHISPER_MODEL_CMD" ]; then
  model_name=$(basename "$WHISPER_MODEL_CMD")
  wake_name=$(basename "$WHISPER_MODEL_WAKE")
  log "Using whisper model (command): $model_name"
  log "Using whisper model (wake): $wake_name"
  log "Wake engine: $WAKE_ENGINE"
  log "Command engine: $CMD_ENGINE"
  notify "Listening (offline: wake $wake_name, cmd $model_name) for '$WAKE_PHRASE'"
  log "Started (whisper offline)"
  speak "Codex voice is live offline."
else
  notify "Listening for '$WAKE_PHRASE'"
  log "Started (termux speech)"
  speak "Codex voice is live."
fi
printf '%s\n' "Hands-free mode ready. Say '$WAKE_PHRASE' to wake. Say 'stop listening' to exit."

while :; do
  now=$(date +%s)
  if [ $((now - last_heartbeat)) -ge "$HEARTBEAT_SECS" ]; then
    if [ -x "$WHISPER_BIN" ] && [ -n "$WHISPER_MODEL_CMD" ] && [ -f "$WHISPER_MODEL_CMD" ]; then
      notify "Listening (offline) for '$WAKE_PHRASE'"
    else
      notify "Listening for '$WAKE_PHRASE'"
    fi
    last_heartbeat=$now
  fi

  text=$(listen_once "$WHISPER_MODEL_WAKE" "$RECORD_SECS_WAKE" "$MIN_OPUS_BYTES_WAKE" "$WHISPER_BS_WAKE" "$WHISPER_BO_WAKE" "$WAKE_ENGINE")
  text=$(printf '%s' "$text" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')

  if [ -z "$text" ]; then
    sleep 0.3
    continue
  fi

  norm=$(normalize_text "$text")
  if is_garbage_transcript "$norm"; then
    continue
  fi

  log "Heard: $norm"
  if [ "$DEBUG_TOAST" = "1" ]; then
    short_norm=$(printf '%.60s' "$norm")
    termux-toast "Heard: $short_norm" >/dev/null 2>&1 || true
  fi

  goto_handle=0

  case "$norm" in
    "stop"|"stop listening"|"quit"|"exit")
      speak "Stopping voice mode."
      exit 0
      ;;
  esac

  if [ "$goto_handle" -eq 0 ]; then
    now=$(date +%s)
    if [ "$wake_ts" -eq 0 ] || [ $((now - wake_ts)) -gt "$WAKE_WINDOW_SECS" ]; then
      wake_buffer=""
    fi
    wake_ts=$now

    if [ -n "$wake_buffer" ]; then
      wake_buffer="$wake_buffer $norm"
    else
      wake_buffer="$norm"
    fi

    wake_buffer=$(printf '%s' "$wake_buffer" | awk -v n=12 '{
      if (NF>n) {for (i=NF-n+1;i<=NF;i++) printf "%s%s", $i, (i==NF?ORS:OFS)}
      else print
    }')

    if ! contains_wake "$wake_buffer"; then
      notify "Heard speech (waiting for '$WAKE_PHRASE')"
      termux-toast "Heard speech" >/dev/null 2>&1 || true
      continue
    fi

    log "Wake detected: $wake_buffer"
    termux-toast "Wake detected" >/dev/null 2>&1 || true
    notify "Heard wake word"
    termux-vibrate -d 80 >/dev/null 2>&1 || true

    cmd=$(strip_wake "$wake_buffer")
    if [ "$cmd" = "$wake_buffer" ]; then
      cmd=""
    fi
    cmd=$(printf '%s' "$cmd" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
    wake_buffer=""
    wake_ts=0

    if [ -z "$cmd" ] || is_garbage_transcript "$cmd"; then
      attempt=0
      while [ $attempt -le "$MAX_COMMAND_RETRIES" ]; do
        notify "Listening..."
        if [ "$SAY_LISTENING" = "1" ]; then
          speak "Listening."
        else
          termux-toast "Say your command..." >/dev/null 2>&1 || true
        fi
        termux-vibrate -d 80 >/dev/null 2>&1 || true
        sleep 0.2
        cmd=$(listen_once "$WHISPER_MODEL_CMD" "$RECORD_SECS_CMD" "$MIN_OPUS_BYTES_CMD" "$WHISPER_BS_CMD" "$WHISPER_BO_CMD" "$CMD_ENGINE")
        cmd=$(normalize_text "$cmd")
        if [ -n "$cmd" ] && ! is_garbage_transcript "$cmd"; then
          break
        fi
        attempt=$((attempt + 1))
        speak "I didn't catch that. Say it again."
      done
    fi

    if [ -z "$cmd" ] || is_garbage_transcript "$cmd"; then
      notify "Listening for '$WAKE_PHRASE'"
      continue
    fi

    case "$cmd" in
      "stop"|"stop listening"|"quit"|"exit")
        speak "Stopping voice mode."
        exit 0
        ;;
    esac
  fi

  notify "Thinking..."
  if [ -n "$session_id" ]; then
    codex exec --skip-git-repo-check --color never \
      --output-last-message "$OUT_FILE" \
      resume "$session_id" "$cmd" >/dev/null 2>&1
    status=$?
  else
    status=1
  fi

  if [ "$status" -ne 0 ]; then
    # Fallback: run a fresh one-shot if resume fails.
    codex exec --skip-git-repo-check --color never \
      --output-last-message "$OUT_FILE" \
      "$cmd" >/dev/null 2>&1
  fi

  notify "Speaking..."
  say_response
  notify "Listening for '$WAKE_PHRASE'"

done
